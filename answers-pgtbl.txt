// Exercise 1: 

* Question: For every page table entry in the print_pgtbl output, explain what it logically contains and what 
its permission bits are. Figure 3.4 in the xv6 book might be helpful, although note that the figure might have 
a slightly different set of pages than process that's being inspected here. Note that xv6 doesn't place the virtual 
pages consecutively in physical memory.

* Answer:

- Pages contain text, data, heap, and special kernel structures.
- Permissions show which pages user code can read, write, or execute.
- Unused pages are zeroed (not mapped).

Lower addresses:
----------------
va 0x00000000 -> Text segment. Perm: 0x5B -> R-XU (read, execute, user)
va 0x00001000 -> Likely read-only data. Perm: 0x1B -> R--U
va 0x00002000 -> Data segment (read/write). Perm: 0x17 -> RW-U
va 0x00003000 -> Heap start. Perm: 0x07 -> RWU
va 0x00004000 -> Heap or syscall page. Perm: 0xD7 -> RWU + Accessed

va 0x00005000–0x00009000 -> Unmapped (permission = 0)

Upper addresses:
----------------
va 0xFFFFD000 -> Trapframe page. Perm: 0x13 -> RW (kernel only)
va 0xFFFFE000 -> User syscall page. Perm: 0xC7 -> RWXU + Accessed
va 0xFFFFF000 -> Trampoline code. Perm: 0x4B -> RX (kernel only)


// Exercise 2: Speed up system calls
* Question: Which other xv6 system call(s) could be made faster using this shared page? Explain how.
* Answer:
These are the xv6 system calls that could be made faster using this shared page:
1/ uptime(): We can make it faster by caching the tick count in usyscall and allow userspace to read it directly.
2/ getppid(): We can make it faster by storing ppid in usyscall and access it directly in userspace.
3/ getuid(): We can make it faster by storing them in usyscall and read them directly.



// Exercise 3: Print a page table
* Question: For every leaf page in the vmprint output, explain what it logically contains and what its permission 
bits are, and how it relates to the output of the earlier print_pgtbl() exercise above. Figure 3.4 in the xv6 book 
might be helpful, although note that the figure might have a slightly different set of pages than the process that's 
being inspected here.
* Answer:
From the output after running pgtbltest, the leaf pages are:
......0: pte 0x0000000021fc7c5b pa 0x0000000087f1f000
......1: pte 0x0000000021fc701b pa 0x0000000087f1c000
......2: pte 0x0000000021fc6cd7 pa 0x0000000087f1b000
......3: pte 0x0000000021fc6807 pa 0x0000000087f1a000
......4: pte 0x0000000021fc64d7 pa 0x0000000087f19000
......509: pte 0x0000000021fd4c13 pa 0x0000000087f53000
......510: pte 0x0000000021fd00c7 pa 0x0000000087f40000
......511: pte 0x000000002000184b pa 0x0000000080006000

1. ......0: pte 0x21fc7c5b pa 0x87f1f000
- Virtual address: 0x0
- Physical address: 0x87f1f000
- Permissions: 0x5B (Valid, Read, Write, Execute, User)
- Meaning: This is a user-accessible code/data page with full RWX permissions. It is likely part of the program's 
main segment.

2. ......1: pte 0x21fc701b pa 0x87f1c000
- Virtual address: 0x1000
- Physical address: 0x87f1c000
- Permissions: 0x1B (Valid, Read, Write, User (No Execute))
- Meaning: User-accessible writable data page.

3. ......2: pte 0x21fc6cd7 pa 0x87f1b000
- Virtual address: 0x2000
- Physical address: 0x87f1b000
- Permissions: 0xD7 (Valid, Read, Execute, User, Global)
- Meaning: Likely user-level code with shared/global permissions.

4. ......3: pte 0x21fc6807 pa 0x87f1a000
- Virtual address: 0x3000
- Physical address: 0x87f1a000
- Permissions: 0x07 (Valid, Read, Write, Execute (no User bit))
- Meaning: Kernel-only RWX page. Not accessible to user space.

5. ......4: pte 0x21fc64d7 pa 0x87f19000
- Virtual address: 0x4000
- Physical address: 0x87f19000
- Permissions: 0xD7 (Valid, Read, Execute, User, Global)
- Meaning: Another user code page, possibly shared.

6. ......509: pte 0x21fd4c13 pa 0x87f53000
- Virtual address: 0xFFFFD000
- Physical address: 0x87f53000
- Permissions: 0x13 (Valid, Read, Execute, User)
- Meaning: A trampoline or trapframe page used during user↔kernel transitions.

7. ......510: pte 0x21fd00c7 pa 0x87f40000
- Virtual address: 0xFFFFE000
- Physical address: 0x87f40000
- Permissions: 0xC7 (Valid, Read, Write, Execute, User)
- Meaning: It is likely the trapframe itself, user-accessible RWX memory for saving registers.

8. ......511: pte 0x2000184b pa 0x80006000
- Virtual address: 0xFFFFF000
- Physical address: 0x80006000
- Permissions: 0x4B (Valid, Read, Execute, User)
- Meaning: Maps to the trampoline page, allows user-to-kernel transition code execution.

Relation to print_pgtbl() output:
- The vmprint() entries exactly match the leaf PTEs shown in the print_pgtbl() output for the first 10 and last 
10 pages. However, print_pgtbl() only showed linear virtual address mappings, while vmprint() shows the full 
hierarchical structure of the page table using indentation to represent depth.
- Both functions show:
 + Pages at 0x0 to 0x4000 with similar permissions
 + Pages at 0xFFFFD000 to 0xFFFFF000 for the trapframe/trampoline
- The values of PTEs and physical addresses also match, confirming that these are the same mappings seen from 
two perspectives.